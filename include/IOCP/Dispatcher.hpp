#ifndef __IOCP_DISPATCHER_HPP
#define __IOCP_DISPATCHER_HPP


#include "Object.hpp"
#include "IOCP.hpp"
#include "AsyncResult.hpp"
#include "WinException.hpp"
#include "../MultiThread/Tls.hpp"

#include <vector>
#include <type_traits>


namespace async
{

	namespace iocp 
	{
		
		namespace detail
		{
			/************************************************************************
			*  
			*	Int2Type		: 常整数映射为类型，由编译期计算出来的结果选择不同的函数，达到静态分派
			*	调用方式			: Int2Type<isPolymorphics>
			*	适用情形			: 有需要根据某个编译期常数调用一个或数个不同的函数
			*					  有必要在编译期实施静态分派
			*
			*	Type2Type		: 利用函数重载机制，模拟template偏特化，利用轻量型型别来传递型别信息
			*
			***********************************************************************/
			template<int v>
			struct Int2Type
			{
				enum { value = v };
			};

			template<typename T>
			struct Type2Type
			{
				typedef T value_type;
			};
		}


		// 获取适合系统的线程数
		inline size_t GetFitThreadNum(size_t perCPU = 2)
		{
			SYSTEM_INFO systemInfo = {0};
			::GetSystemInfo(&systemInfo);

			return perCPU * systemInfo.dwNumberOfProcessors + 2;
		}



		//------------------------------------------------------------------
		// class IODispatcher
		// 完成端口实现

		class IODispatcher
		{
		public:
			// 线程容器类型
			typedef std::vector<HANDLE>			Threads;
			typedef Threads::const_iterator		ThreadsIter;
			typedef std::tr1::function<void()>	InitCallback;
			typedef std::tr1::function<void()>	UninitCallback;

		private:
			// iocp Handle
			Iocp iocp_;
			// 线程容器
			std::vector<HANDLE>	threads_;
			// 线程创建后初始化操作
			InitCallback initCallback_;
			// 线程退出时结束操作
			UninitCallback unInitCallback_;

		public:
			explicit IODispatcher(size_t numThreads = GetFitThreadNum(), const InitCallback &init = 0, const UninitCallback &unint = 0);
			~IODispatcher();

		public:
			// 设置初始化及结束操作
			//void Register(const InitCallback &init, const UninitCallback &unint);
			// 绑定设备到完成端口
			void Bind(HANDLE);
			// 向完成端口投递请求
			template<typename HandlerT>
			void Post(const HandlerT &handler);
			// 当仅不在线程池中时才向调度器中分派
			template<typename HandlerT>
			void Dispatch(const HandlerT &handler);

			// 停止服务
			void Stop();

		private:
			void _ThreadIO();

		private:
			static size_t WINAPI _ThreadIOImpl(LPVOID);
		};


		template < typename HandlerT >
		void IODispatcher::Post(const HandlerT &handler)
		{
			AsyncCallbackBasePtr async(MakeAsyncCallback(handler));

			async->AddRef();
			if( !iocp_.PostStatus(reinterpret_cast<ULONG_PTR>(&*(async.Get())), 0, 0) )
				throw Win32Exception("iocp_.PostStatus");
		}

		template < typename HandlerT >
		void IODispatcher::Dispatch(const HandlerT &handler)
		{
			if( async::thread::CallStack<IODispatcher>::Contains(this) )
			{
				AsyncCallbackBasePtr async(MakeAsyncCallback(handler));
				AsyncCallbackBase::Call(async);
			}
			else
				Post(handler);
		}
	}
}



#endif